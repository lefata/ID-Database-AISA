import { supabase } from './lib/supabaseClient';
import 'dotenv/config';

const REQUIRED_SQL = `
-- 1. Create the 'people' table
CREATE TABLE IF NOT EXISTS public.people (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  category VARCHAR(20) NOT NULL,
  "firstName" VARCHAR(50) NOT NULL,
  "lastName" VARCHAR(50) NOT NULL,
  image TEXT NOT NULL,
  role VARCHAR(50),
  class VARCHAR(50),
  "guardianIds" BIGINT[],
  bio TEXT NOT NULL,
  "googleSheetId" VARCHAR(20) NOT NULL,
  "createdAt" TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- 2. Create the 'settings' table
CREATE TABLE IF NOT EXISTS public.settings (
  key TEXT PRIMARY KEY,
  value TEXT
);

-- 3. Create the 'is_admin' function for RLS
CREATE OR REPLACE FUNCTION is_admin()
RETURNS BOOLEAN
LANGUAGE SQL
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT COALESCE((auth.jwt() -> 'user_metadata' ->> 'role') = 'admin', FALSE)
$$;

-- 4. Apply Row Level Security (RLS) policies for tables
ALTER TABLE public.people ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow authenticated read access" ON public.people;
CREATE POLICY "Allow authenticated read access" ON public.people FOR SELECT TO authenticated USING (TRUE);
DROP POLICY IF EXISTS "Allow authenticated insert access" ON public.people;
CREATE POLICY "Allow authenticated insert access" ON public.people FOR INSERT TO authenticated WITH CHECK (TRUE);
DROP POLICY IF EXISTS "Allow admin update access" ON public.people;
CREATE POLICY "Allow admin update access" ON public.people FOR UPDATE USING (is_admin()) WITH CHECK (is_admin());

ALTER TABLE public.settings ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow authenticated read access on settings" ON public.settings;
CREATE POLICY "Allow authenticated read access on settings" ON public.settings FOR SELECT TO authenticated USING (TRUE);
DROP POLICY IF EXISTS "Allow admin insert access on settings" ON public.settings;
CREATE POLICY "Allow admin insert access on settings" ON public.settings FOR INSERT WITH CHECK (is_admin());
DROP POLICY IF EXISTS "Allow admin update access on settings" ON public.settings;
CREATE POLICY "Allow admin update access on settings" ON public.settings FOR UPDATE USING (is_admin()) WITH CHECK (is_admin());


-- 5. Create a trigger to make the first user an admin
CREATE OR REPLACE FUNCTION public.grant_first_user_admin()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Check if this is the very first user
  IF (SELECT count(*) FROM auth.users) = 1 THEN
    -- If so, grant admin role and confirm their email
    UPDATE auth.users
    SET
      user_metadata = jsonb_set(
        COALESCE(user_metadata, '{}'::jsonb),
        '{role}',
        '"admin"'::jsonb
      ),
      email_confirmed_at = NOW()
    WHERE id = NEW.id;
  END IF;
  RETURN NEW;
END;
$$;

-- Drop the trigger if it already exists to ensure idempotency
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Add the trigger to the auth.users table
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.grant_first_user_admin();

-- 6. Create Storage bucket policies for 'avatars'
-- NOTE: You must manually create a PUBLIC bucket named 'avatars' in the Supabase UI first.
-- This SQL only sets the security policies for it.
DROP POLICY IF EXISTS "Allow authenticated uploads to avatars" ON storage.objects;
CREATE POLICY "Allow authenticated uploads to avatars"
ON storage.objects FOR INSERT TO authenticated
WITH CHECK ( bucket_id = 'avatars' );

DROP POLICY IF EXISTS "Allow public read access to avatars" ON storage.objects;
CREATE POLICY "Allow public read access to avatars"
ON storage.objects FOR SELECT
USING ( bucket_id = 'avatars' );
`.trim();


async function checkAndSeed() {
  console.log('üöÄ Starting Supabase database setup...');

  try {
    // 1. Check if the 'people' table exists to verify basic setup.
    console.log('‚ÑπÔ∏è Verifying database schema...');
    const { error: tableCheckError } = await supabase.from('people').select('id').limit(1);

    if (tableCheckError && tableCheckError.code === '42P01') { // 42P01 is "undefined_table" in Postgres
      console.error('‚ùå ERROR: One or more required tables were not found.');
      console.log('---------------------------------------------------------------------------------');
      console.log('Please run all the following SQL commands in your Supabase SQL Editor:');
      console.log('\n' + REQUIRED_SQL + '\n');
      console.log('After creating the tables and policies, re-run this script: `npm run db:setup`');
      console.log('---------------------------------------------------------------------------------');
      (process as any).exit(1);
    } else if (tableCheckError) {
      throw new Error(`Failed to check tables: ${tableCheckError.message}`);
    }
    console.log('‚úÖ Database schema verified.');

    // 2. Check if settings are seeded
    const { data: settings, error: settingsError } = await supabase.from('settings').select('key');
    if(settingsError) throw settingsError;
    
    if (!settings.find(s => s.key === 'googleSheetId')) {
        console.log('üå± Seeding initial settings...');
        await supabase.from('settings').upsert({
            key: 'googleSheetId',
            value: 'your-sheet-id-here'
        });
        console.log('‚úÖ Initial settings seeded.');
    } else {
        console.log('‚ÑπÔ∏è Settings already exist, skipping seed.');
    }

    // 3. Check if people data is seeded
    const { count, error: countError } = await supabase.from('people').select('*', { count: 'exact', head: true });
    if (countError) throw countError;

    if (count !== null && count > 0) {
        console.log('‚ÑπÔ∏è People data already exists, skipping seed.');
    } else {
        console.log('üå± Seeding database with initial people data...');
        await seedPeople();
        console.log('‚úÖ Initial people data seeded successfully.');
    }

    console.log('‚ú® Database setup complete! You can now run `npm run dev` to start the application.');

  } catch (error) {
    console.error('‚ùå An error occurred during database setup:', error);
    console.error('Please ensure your Supabase project is running and the environment variables are correct.');
    (process as any).exit(1);
  }
}

async function seedPeople() {
    await supabase.from('people').insert({
        category: 'Staff', firstName: 'Eleanor', lastName: 'Vance', role: 'Principal', image: 'https://picsum.photos/seed/eleanor/200/200', bio: 'A visionary leader dedicated to fostering an inspiring learning environment.', googleSheetId: 'GS-83610'
    });
    const { data: marcus } = await supabase.from('people').insert({
        category: 'Parent/Guardian', firstName: 'Marcus', lastName: 'Cole', role: 'Parent/Guardian', image: 'https://picsum.photos/seed/marcus/200/200', bio: 'An engaged parent committed to supporting the school community.', googleSheetId: 'GS-19283'
    }).select('id').single();
    const { data: olivia } = await supabase.from('people').insert({
        category: 'Parent/Guardian', firstName: 'Olivia', lastName: 'Chen', role: 'Parent/Guardian', image: 'https://picsum.photos/seed/olivia/200/200', bio: 'A creative and supportive presence in our community.', googleSheetId: 'GS-55431'
    }).select('id').single();
    if (!marcus || !olivia) throw new Error('Failed to create parent records for seeding.');
    await supabase.from('people').insert({
        category: 'Student', firstName: 'Leo', lastName: 'Cole', class: 'Grade 5', image: 'https://picsum.photos/seed/leo/200/200', bio: 'A curious and bright student with a passion for science.', googleSheetId: 'GS-48265', guardianIds: [marcus.id, olivia.id]
    });
}

checkAndSeed();