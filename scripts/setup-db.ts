import { supabase } from './lib/supabaseClient';
import 'dotenv/config';

const REQUIRED_SQL = `
-- 1. Create the 'people' table
CREATE TABLE IF NOT EXISTS public.people (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  category VARCHAR(20) NOT NULL,
  "firstName" VARCHAR(50) NOT NULL,
  "lastName" VARCHAR(50) NOT NULL,
  image TEXT NOT NULL,
  role VARCHAR(50),
  class VARCHAR(50),
  "guardianIds" BIGINT[],
  bio TEXT NOT NULL,
  "googleSheetId" VARCHAR(20) NOT NULL,
  "createdAt" TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- 2. Create the 'settings' table
CREATE TABLE IF NOT EXISTS public.settings (
  key TEXT PRIMARY KEY,
  value TEXT
);

-- 3. Create 'access_logs' table
CREATE TABLE IF NOT EXISTS public.access_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  person_id BIGINT NOT NULL REFERENCES public.people(id) ON DELETE CASCADE,
  direction VARCHAR(5) NOT NULL CHECK (direction IN ('entry', 'exit')),
  recorded_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_access_logs_person_id ON public.access_logs(person_id);
CREATE INDEX IF NOT EXISTS idx_access_logs_created_at ON public.access_logs(created_at DESC);


-- 4. Create helper functions for RLS
CREATE OR REPLACE FUNCTION is_admin()
RETURNS BOOLEAN
LANGUAGE SQL
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT COALESCE((auth.jwt() -> 'user_metadata' ->> 'role') = 'admin', FALSE)
$$;

CREATE OR REPLACE FUNCTION is_admin_or_security()
RETURNS BOOLEAN
LANGUAGE SQL
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT COALESCE((auth.jwt() -> 'user_metadata' ->> 'role') = 'admin', (auth.jwt() -> 'user_metadata' ->> 'role') = 'security', FALSE)
$$;


-- 5. Apply Row Level Security (RLS) policies for tables
ALTER TABLE public.people ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow authenticated read access" ON public.people;
CREATE POLICY "Allow authenticated read access" ON public.people FOR SELECT TO authenticated USING (TRUE);
DROP POLICY IF EXISTS "Allow authenticated insert access" ON public.people;
CREATE POLICY "Allow authenticated insert access" ON public.people FOR INSERT TO authenticated WITH CHECK (TRUE);
DROP POLICY IF EXISTS "Allow admin update access" ON public.people;
CREATE POLICY "Allow admin update access" ON public.people FOR UPDATE USING (is_admin()) WITH CHECK (is_admin());

ALTER TABLE public.settings ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow authenticated read access on settings" ON public.settings;
CREATE POLICY "Allow authenticated read access on settings" ON public.settings FOR SELECT TO authenticated USING (TRUE);
DROP POLICY IF EXISTS "Allow admin insert/update access on settings" ON public.settings;
CREATE POLICY "Allow admin insert/update access on settings" ON public.settings FOR ALL USING (is_admin()) WITH CHECK (is_admin());

ALTER TABLE public.access_logs ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Allow admin/security to read logs" ON public.access_logs;
CREATE POLICY "Allow admin/security to read logs" ON public.access_logs FOR SELECT USING (is_admin_or_security());
DROP POLICY IF EXISTS "Allow admin/security to insert logs" ON public.access_logs;
CREATE POLICY "Allow admin/security to insert logs" ON public.access_logs FOR INSERT WITH CHECK (is_admin_or_security());


-- 6. Create a trigger to make the first user an admin
CREATE OR REPLACE FUNCTION public.grant_first_user_admin()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Check if this is the very first user
  IF (SELECT count(*) FROM auth.users) = 1 THEN
    -- If so, grant admin role and confirm their email
    UPDATE auth.users
    SET
      user_metadata = jsonb_set(
        COALESCE(user_metadata, '{}'::jsonb),
        '{role}',
        '"admin"'::jsonb
      ),
      email_confirmed_at = NOW()
    WHERE id = NEW.id;
  END IF;
  RETURN NEW;
END;
$$;

-- Drop the trigger if it already exists to ensure idempotency
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Add the trigger to the auth.users table
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.grant_first_user_admin();

-- 7. Create Storage bucket policies for 'avatars'
DROP POLICY IF EXISTS "Allow authenticated uploads to avatars" ON storage.objects;
CREATE POLICY "Allow authenticated uploads to avatars"
ON storage.objects FOR INSERT TO authenticated
WITH CHECK ( bucket_id = 'avatars' );

DROP POLICY IF EXISTS "Allow public read access to avatars" ON storage.objects;
CREATE POLICY "Allow public read access to avatars"
ON storage.objects FOR SELECT
USING ( bucket_id = 'avatars' );

-- 8. Create the analytics function
CREATE OR REPLACE FUNCTION get_parent_analytics()
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN (
        WITH parent_logs_today AS (
            SELECT
                l.person_id,
                l.direction,
                l.created_at
            FROM
                access_logs l
            JOIN
                people p ON l.person_id = p.id
            WHERE
                p.category = 'Parent/Guardian' AND
                l.created_at >= date_trunc('day', now() at time zone 'utc')
        ),
        last_action AS (
            SELECT DISTINCT ON (person_id)
                person_id,
                direction
            FROM
                access_logs -- Query all logs, not just today's
            JOIN
                people p ON access_logs.person_id = p.id
            WHERE 
                p.category = 'Parent/Guardian'
            ORDER BY
                person_id, created_at DESC
        )
        SELECT jsonb_build_object(
            'on_campus', (SELECT count(*) FROM last_action WHERE direction = 'entry'),
            'entries_today', (SELECT count(*) FROM parent_logs_today WHERE direction = 'entry'),
            'exits_today', (SELECT count(*) FROM parent_logs_today WHERE direction = 'exit')
        )
    );
END;
$$;


-- 9. Create the schema verification and repair function
CREATE OR REPLACE FUNCTION verify_and_repair_schema()
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    logs jsonb := '[]'::jsonb;
BEGIN
    -- Tables
    IF NOT EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename  = 'people') THEN
        CREATE TABLE public.people (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, category VARCHAR(20) NOT NULL, "firstName" VARCHAR(50) NOT NULL, "lastName" VARCHAR(50) NOT NULL, image TEXT NOT NULL, role VARCHAR(50), class VARCHAR(50), "guardianIds" BIGINT[], bio TEXT NOT NULL, "googleSheetId" VARCHAR(20) NOT NULL, "createdAt" TIMESTAMPTZ DEFAULT NOW() NOT NULL);
        logs := logs || jsonb_build_object('status', 'success', 'step', 'Create Table: people', 'details', 'Table "people" did not exist and was created.');
    ELSE logs := logs || jsonb_build_object('status', 'info', 'step', 'Check Table: people', 'details', 'Table "people" already exists.'); END IF;
    IF NOT EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename  = 'settings') THEN
        CREATE TABLE public.settings (key TEXT PRIMARY KEY, value TEXT);
        logs := logs || jsonb_build_object('status', 'success', 'step', 'Create Table: settings', 'details', 'Table "settings" did not exist and was created.');
    ELSE logs := logs || jsonb_build_object('status', 'info', 'step', 'Check Table: settings', 'details', 'Table "settings" already exists.'); END IF;
    IF NOT EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename  = 'access_logs') THEN
        CREATE TABLE public.access_logs (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, person_id BIGINT NOT NULL REFERENCES public.people(id) ON DELETE CASCADE, direction VARCHAR(5) NOT NULL CHECK (direction IN ('entry', 'exit')), recorded_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE SET NULL, created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL);
        CREATE INDEX IF NOT EXISTS idx_access_logs_person_id ON public.access_logs(person_id);
        CREATE INDEX IF NOT EXISTS idx_access_logs_created_at ON public.access_logs(created_at DESC);
        logs := logs || jsonb_build_object('status', 'success', 'step', 'Create Table: access_logs', 'details', 'Table "access_logs" did not exist and was created.');
    ELSE logs := logs || jsonb_build_object('status', 'info', 'step', 'Check Table: access_logs', 'details', 'Table "access_logs" already exists.'); END IF;
    
    -- RLS helper functions
    CREATE OR REPLACE FUNCTION is_admin() RETURNS BOOLEAN LANGUAGE SQL SECURITY DEFINER SET search_path = public AS $func$ SELECT COALESCE((auth.jwt() -> 'user_metadata' ->> 'role') = 'admin', FALSE) $func$;
    CREATE OR REPLACE FUNCTION is_admin_or_security() RETURNS BOOLEAN LANGUAGE SQL SECURITY DEFINER SET search_path = public AS $func_sec$ SELECT COALESCE((auth.jwt() -> 'user_metadata' ->> 'role') = 'admin', (auth.jwt() -> 'user_metadata' ->> 'role') = 'security', FALSE) $func_sec$;
    logs := logs || jsonb_build_object('status', 'success', 'step', 'Create/Replace RLS Functions', 'details', 'Functions "is_admin" and "is_admin_or_security" were created or updated.');
    
    -- Analytics function
    CREATE OR REPLACE FUNCTION get_parent_analytics() RETURNS jsonb LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $analytics_func$ BEGIN RETURN (WITH parent_logs_today AS (SELECT l.person_id,l.direction,l.created_at FROM access_logs l JOIN people p ON l.person_id = p.id WHERE p.category = 'Parent/Guardian' AND l.created_at >= date_trunc('day', now() at time zone 'utc')), last_action AS (SELECT DISTINCT ON (person_id) person_id,direction FROM access_logs JOIN people p ON access_logs.person_id = p.id WHERE p.category = 'Parent/Guardian' ORDER BY person_id, created_at DESC) SELECT jsonb_build_object('on_campus', (SELECT count(*) FROM last_action WHERE direction = 'entry'),'entries_today', (SELECT count(*) FROM parent_logs_today WHERE direction = 'entry'),'exits_today', (SELECT count(*) FROM parent_logs_today WHERE direction = 'exit'))); END; $analytics_func$;
    logs := logs || jsonb_build_object('status', 'success', 'step', 'Create/Replace Analytics Function', 'details', 'Function "get_parent_analytics" was created or updated.');

    -- RLS policies
    ALTER TABLE public.people ENABLE ROW LEVEL SECURITY;
    DROP POLICY IF EXISTS "Allow authenticated read access" ON public.people; CREATE POLICY "Allow authenticated read access" ON public.people FOR SELECT TO authenticated USING (TRUE);
    DROP POLICY IF EXISTS "Allow authenticated insert access" ON public.people; CREATE POLICY "Allow authenticated insert access" ON public.people FOR INSERT TO authenticated WITH CHECK (TRUE);
    DROP POLICY IF EXISTS "Allow admin update access" ON public.people; CREATE POLICY "Allow admin update access" ON public.people FOR UPDATE USING (is_admin()) WITH CHECK (is_admin());
    ALTER TABLE public.settings ENABLE ROW LEVEL SECURITY;
    DROP POLICY IF EXISTS "Allow authenticated read access on settings" ON public.settings; CREATE POLICY "Allow authenticated read access on settings" ON public.settings FOR SELECT TO authenticated USING (TRUE);
    DROP POLICY IF EXISTS "Allow admin insert/update access on settings" ON public.settings; CREATE POLICY "Allow admin insert/update access on settings" ON public.settings FOR ALL USING (is_admin()) WITH CHECK (is_admin());
    ALTER TABLE public.access_logs ENABLE ROW LEVEL SECURITY;
    DROP POLICY IF EXISTS "Allow admin/security to read logs" ON public.access_logs; CREATE POLICY "Allow admin/security to read logs" ON public.access_logs FOR SELECT USING (is_admin_or_security());
    DROP POLICY IF EXISTS "Allow admin/security to insert logs" ON public.access_logs; CREATE POLICY "Allow admin/security to insert logs" ON public.access_logs FOR INSERT WITH CHECK (is_admin_or_security());
    logs := logs || jsonb_build_object('status', 'success', 'step', 'Apply RLS Policies', 'details', 'RLS policies for all tables have been applied/re-applied.');

    -- Admin Trigger
    CREATE OR REPLACE FUNCTION public.grant_first_user_admin() RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER AS $trigger_func$ BEGIN IF (SELECT count(*) FROM auth.users) = 1 THEN UPDATE auth.users SET user_metadata = jsonb_set(COALESCE(user_metadata, '{}'::jsonb), '{role}', '"admin"'::jsonb), email_confirmed_at = NOW() WHERE id = NEW.id; END IF; RETURN NEW; END; $trigger_func$;
    DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users; CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.grant_first_user_admin();
    logs := logs || jsonb_build_object('status', 'success', 'step', 'Apply Admin Trigger', 'details', 'Trigger "on_auth_user_created" has been applied/re-applied.');
    
    -- Storage Policies
    DROP POLICY IF EXISTS "Allow authenticated uploads to avatars" ON storage.objects; CREATE POLICY "Allow authenticated uploads to avatars" ON storage.objects FOR INSERT TO authenticated WITH CHECK ( bucket_id = 'avatars' );
    DROP POLICY IF EXISTS "Allow public read access to avatars" ON storage.objects; CREATE POLICY "Allow public read access to avatars" ON storage.objects FOR SELECT USING ( bucket_id = 'avatars' );
    logs := logs || jsonb_build_object('status', 'success', 'step', 'Apply Storage Policies', 'details', 'Security policies for "avatars" bucket have been applied/re-applied.');

    RETURN logs;
END;
$$;
`.trim();


async function checkAndCreateStorageBucket() {
  console.log("‚ÑπÔ∏è Verifying 'avatars' storage bucket...");
  try {
    const { error } = await supabase.storage.getBucket('avatars');
    
    if (error && error.message.includes('Bucket not found')) {
      console.log("üü° 'avatars' bucket not found. Attempting to create it...");
      const { error: createError } = await supabase.storage.createBucket('avatars', {
        public: true,
      });

      if (createError) {
        throw new Error(`Failed to create 'avatars' bucket: ${createError.message}`);
      }
      console.log("‚úÖ 'avatars' bucket created successfully.");
    } else if (error) {
      throw new Error(`Failed to check for 'avatars' bucket: ${error.message}`);
    } else {
      console.log("‚úÖ 'avatars' bucket already exists.");
    }
  } catch (err: any) {
    console.error(`‚ùå An error occurred during storage bucket setup: ${err.message}`);
    console.error('Please ensure your Supabase SERVICE_ROLE_KEY has permissions to manage storage.');
    throw err;
  }
}

async function checkAndSeed() {
  console.log('üöÄ Starting Supabase database setup & verification...');

  try {
    // 1. Verify and create the storage bucket.
    await checkAndCreateStorageBucket();
      
    // 2. Verify the schema by checking for the self-repair function.
    // This is the most reliable way to detect an outdated schema.
    console.log('‚ÑπÔ∏è Verifying database schema by checking for the self-repair function...');
    const { error: rpcError } = await supabase.rpc('verify_and_repair_schema');

    if (rpcError && rpcError.message.includes('Could not find the function')) {
        console.error('‚ùå ERROR: Your database schema is outdated because the `verify_and_repair_schema` function is missing.');
        console.log('---------------------------------------------------------------------------------');
        console.log('SOLUTION: Please run the following SQL script in your Supabase SQL Editor to update your schema.');
        console.log('This script is idempotent (safe to run multiple times) and will create the necessary function.');
        console.log('\n' + REQUIRED_SQL + '\n');
        console.log('After running the script, re-run this command: `npm run db:setup`');
        console.log('---------------------------------------------------------------------------------');
        (process as any).exit(1);
    } else if (rpcError) {
        console.error('‚ùå An unexpected error occurred while verifying the schema:', rpcError);
        (process as any).exit(1);
    } else {
        console.log('‚úÖ Database schema is up-to-date.');
    }

    // 3. Check if settings are seeded
    const { data: settings, error: settingsError } = await supabase.from('settings').select('key');
    if(settingsError) throw settingsError;
    
    if (!settings.find(s => s.key === 'googleSheetId')) {
        console.log('üå± Seeding initial settings...');
        await supabase.from('settings').upsert({
            key: 'googleSheetId',
            value: 'your-sheet-id-here'
        });
        console.log('‚úÖ Initial settings seeded.');
    } else {
        console.log('‚ÑπÔ∏è Settings already exist, skipping seed.');
    }

    // 4. Check if people data is seeded
    const { count, error: countError } = await supabase.from('people').select('*', { count: 'exact', head: true });
    if (countError) throw countError;

    if (count !== null && count > 0) {
        console.log('‚ÑπÔ∏è People data already exists, skipping seed.');
    } else {
        console.log('üå± Seeding database with initial people data...');
        await seedPeople();
        console.log('‚úÖ Initial people data seeded successfully.');
    }

    console.log('‚ú® Database setup complete! You can now run `npm run dev` to start the application.');

  } catch (error) {
    console.error('‚ùå An error occurred during database setup:', error);
    console.error('Please ensure your Supabase project is running and the environment variables are correct.');
    (process as any).exit(1);
  }
}

async function seedPeople() {
    await supabase.from('people').insert({
        category: 'Staff', firstName: 'Eleanor', lastName: 'Vance', role: 'Principal', image: 'https://picsum.photos/seed/eleanor/200/200', bio: 'A visionary leader dedicated to fostering an inspiring learning environment.', googleSheetId: 'GS-83610'
    });
    const { data: marcus } = await supabase.from('people').insert({
        category: 'Parent/Guardian', firstName: 'Marcus', lastName: 'Cole', role: 'Parent/Guardian', image: 'https://picsum.photos/seed/marcus/200/200', bio: 'An engaged parent committed to supporting the school community.', googleSheetId: 'GS-19283'
    }).select('id').single();
    const { data: olivia } = await supabase.from('people').insert({
        category: 'Parent/Guardian', firstName: 'Olivia', lastName: 'Chen', role: 'Parent/Guardian', image: 'https://picsum.photos/seed/olivia/200/200', bio: 'A creative and supportive presence in our community.', googleSheetId: 'GS-55431'
    }).select('id').single();
    if (!marcus || !olivia) throw new Error('Failed to create parent records for seeding.');
    await supabase.from('people').insert({
        category: 'Student', firstName: 'Leo', lastName: 'Cole', class: 'Grade 5', image: 'https://picsum.photos/seed/leo/200/200', bio: 'A curious and bright student with a passion for science.', googleSheetId: 'GS-48265', guardianIds: [marcus.id, olivia.id]
    });
}

checkAndSeed();