import { Hono } from 'hono';
import { handle } from 'hono/vercel';
import { GoogleGenAI, GenerateContentResponse } from '@google/genai';
import { createClient, type SupabaseClient, type User } from '@supabase/supabase-js';
import { MiddlewareHandler } from 'hono';

export const config = {
  runtime: 'edge',
};

const VERIFY_REPAIR_FUNCTION_SQL = `
CREATE OR REPLACE FUNCTION verify_and_repair_schema()
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    logs jsonb := '[]'::jsonb;
BEGIN
    -- Elevate privileges to postgres superuser for this transaction
    SET LOCAL ROLE postgres;

    -- Tables
    IF NOT EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename  = 'people') THEN
        CREATE TABLE public.people (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, category VARCHAR(20) NOT NULL, "firstName" VARCHAR(50) NOT NULL, "lastName" VARCHAR(50) NOT NULL, image TEXT NOT NULL, role VARCHAR(50), class VARCHAR(50), "guardianIds" BIGINT[], bio TEXT NOT NULL, "googleSheetId" VARCHAR(20) NOT NULL, "createdAt" TIMESTAMPTZ DEFAULT NOW() NOT NULL);
        logs := logs || jsonb_build_object('status', 'success', 'step', 'Create Table: people', 'details', 'Table "people" did not exist and was created.');
    ELSE logs := logs || jsonb_build_object('status', 'info', 'step', 'Check Table: people', 'details', 'Table "people" already exists.'); END IF;
    IF NOT EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename  = 'settings') THEN
        CREATE TABLE public.settings (key TEXT PRIMARY KEY, value TEXT);
        logs := logs || jsonb_build_object('status', 'success', 'step', 'Create Table: settings', 'details', 'Table "settings" did not exist and was created.');
    ELSE logs := logs || jsonb_build_object('status', 'info', 'step', 'Check Table: settings', 'details', 'Table "settings" already exists.'); END IF;
    IF NOT EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename  = 'access_logs') THEN
        CREATE TABLE public.access_logs (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, person_id BIGINT NOT NULL REFERENCES public.people(id) ON DELETE CASCADE, direction VARCHAR(5) NOT NULL CHECK (direction IN ('entry', 'exit')), recorded_by UUID NOT NULL REFERENCES auth.users(id) ON DELETE SET NULL, location TEXT DEFAULT 'Unknown Location' NOT NULL, created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL);
        CREATE INDEX IF NOT EXISTS idx_access_logs_person_id ON public.access_logs(person_id);
        CREATE INDEX IF NOT EXISTS idx_access_logs_created_at ON public.access_logs(created_at DESC);
        logs := logs || jsonb_build_object('status', 'success', 'step', 'Create Table: access_logs', 'details', 'Table "access_logs" did not exist and was created.');
    ELSE 
        logs := logs || jsonb_build_object('status', 'info', 'step', 'Check Table: access_logs', 'details', 'Table "access_logs" already exists.');
        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='access_logs' AND column_name='location') THEN
            ALTER TABLE public.access_logs ADD COLUMN location TEXT DEFAULT 'Unknown Location' NOT NULL;
            logs := logs || jsonb_build_object('status', 'success', 'step', 'Alter Table: access_logs', 'details', 'Column "location" was added successfully.');
        END IF;
    END IF;
    
    -- RLS helper functions
    CREATE OR REPLACE FUNCTION is_admin() RETURNS BOOLEAN LANGUAGE SQL SECURITY DEFINER SET search_path = public AS $func$ SELECT COALESCE((auth.jwt() -> 'user_metadata' ->> 'role') = 'admin', FALSE) $func$;
    CREATE OR REPLACE FUNCTION is_admin_or_security() RETURNS BOOLEAN LANGUAGE SQL SECURITY DEFINER SET search_path = public AS $func_sec$ SELECT COALESCE((auth.jwt() -> 'user_metadata' ->> 'role') = 'admin', (auth.jwt() -> 'user_metadata' ->> 'role') = 'security', FALSE) $func_sec$;
    logs := logs || jsonb_build_object('status', 'success', 'step', 'Create/Replace RLS Functions', 'details', 'Functions "is_admin" and "is_admin_or_security" were created or updated.');

    -- Analytics function
    CREATE OR REPLACE FUNCTION get_parent_analytics() RETURNS jsonb LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $analytics_func$ BEGIN RETURN (WITH parent_logs_today AS (SELECT l.person_id,l.direction,l.created_at FROM access_logs l JOIN people p ON l.person_id = p.id WHERE p.category = 'Parent/Guardian' AND l.created_at >= date_trunc('day', now() at time zone 'utc')), last_action AS (SELECT DISTINCT ON (person_id) person_id,direction FROM access_logs JOIN people p ON access_logs.person_id = p.id WHERE p.category = 'Parent/Guardian' ORDER BY person_id, created_at DESC) SELECT jsonb_build_object('on_campus', (SELECT count(*) FROM last_action WHERE direction = 'entry'),'entries_today', (SELECT count(*) FROM parent_logs_today WHERE direction = 'entry'),'exits_today', (SELECT count(*) FROM parent_logs_today WHERE direction = 'exit'))); END; $analytics_func$;
    logs := logs || jsonb_build_object('status', 'success', 'step', 'Create/Replace Analytics Function', 'details', 'Function "get_parent_analytics" was created or updated.');

    -- RLS policies
    ALTER TABLE public.people ENABLE ROW LEVEL SECURITY;
    DROP POLICY IF EXISTS "Allow authenticated read access" ON public.people; CREATE POLICY "Allow authenticated read access" ON public.people FOR SELECT TO authenticated USING (TRUE);
    DROP POLICY IF EXISTS "Allow authenticated insert access" ON public.people; CREATE POLICY "Allow authenticated insert access" ON public.people FOR INSERT TO authenticated WITH CHECK (TRUE);
    DROP POLICY IF EXISTS "Allow admin update access" ON public.people; CREATE POLICY "Allow admin update access" ON public.people FOR UPDATE USING (is_admin()) WITH CHECK (is_admin());
    ALTER TABLE public.settings ENABLE ROW LEVEL SECURITY;
    DROP POLICY IF EXISTS "Allow authenticated read access on settings" ON public.settings; CREATE POLICY "Allow authenticated read access on settings" ON public.settings FOR SELECT TO authenticated USING (TRUE);
    DROP POLICY IF EXISTS "Allow admin insert/update access on settings" ON public.settings; CREATE POLICY "Allow admin insert/update access on settings" ON public.settings FOR ALL USING (is_admin()) WITH CHECK (is_admin());
    ALTER TABLE public.access_logs ENABLE ROW LEVEL SECURITY;
    DROP POLICY IF EXISTS "Allow admin/security to read logs" ON public.access_logs; CREATE POLICY "Allow admin/security to read logs" ON public.access_logs FOR SELECT USING (is_admin_or_security());
    DROP POLICY IF EXISTS "Allow admin/security to insert logs" ON public.access_logs; CREATE POLICY "Allow admin/security to insert logs" ON public.access_logs FOR INSERT WITH CHECK (is_admin_or_security());
    logs := logs || jsonb_build_object('status', 'success', 'step', 'Apply RLS Policies', 'details', 'RLS policies for all tables have been applied/re-applied.');

    RESET ROLE;
    RETURN logs;
EXCEPTION WHEN OTHERS THEN
    RESET ROLE;
    RAISE;
END;
$$;
`;

const createSheetErrorWarning = (studentName: string, errorMessage: string): string => {
    let cleanError = `Could not retrieve Google Sheet ID for ${studentName}. A random ID was assigned.`;
    if (errorMessage.includes('Failed to fetch Google Sheet configuration')) {
        cleanError += ` REASON: ${errorMessage}. Please check database permissions or server logs.`;
    } else if (errorMessage.includes('SERVICE_DISABLED') || errorMessage.includes('API has not been used')) {
        cleanError += ' REASON: The Google Sheets API is not enabled for your project. Please check your Google Cloud Console and follow the setup instructions in the README.';
    } else if (errorMessage.includes('PERMISSION_DENIED') || errorMessage.includes('403')) {
        cleanError += ' REASON: Permission denied. Please ensure your API key is correct and the Google Sheet is public ("Anyone with the link can view").';
    } else if (errorMessage.includes('timed out')) {
        cleanError += ' REASON: The request to Google Sheets timed out. Please try again later.';
    } else if (errorMessage.includes('404') || errorMessage.includes('Not Found')) {
        cleanError += ' REASON: The sheet was not found. Please verify the Google Sheet ID in the Admin Dashboard is correct.';
    } else {
         cleanError += ' REASON: An unexpected error occurred. Please check the API configuration, ensure the sheet is public, and that the student\'s name exists in the sheet.';
    }
    return cleanError;
};

const withTimeout = <T>(promise: Promise<T>, ms: number): Promise<T> => {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      reject(new Error(`Operation timed out after ${ms}ms`));
    }, ms);

    promise.then(
      (res) => {
        clearTimeout(timer);
        resolve(res);
      },
      (err) => {
        clearTimeout(timer);
        reject(err);
      }
    );
  });
};

async function getSheetIdForStudent(supabase: SupabaseClient, firstName: string, lastName: string): Promise<string | null> {
    const { data: settingsData, error: settingsError } = await supabase
      .from('settings')
      .select('value')
      .eq('key', 'googleSheetId')
      .single();
      
    if (settingsError) {
        console.error('Could not fetch googleSheetId from settings:', settingsError);
        // Throw an error to be caught by the caller, which will generate a user warning.
        throw new Error(`Failed to fetch Google Sheet configuration from database: ${settingsError.message}`);
    }

    const sheetId = settingsData?.value;
    const apiKey = process.env.API_KEY_ALIAS_FOR_GEMINI;
    const sheetName = process.env.GOOGLE_SHEET_NAME || 'Sheet1';

    if (!sheetId || !apiKey || sheetId.includes('your-sheet-id-here')) {
        let warning = 'Google Sheet lookup is disabled. Missing or invalid configuration:';
        if (!sheetId || sheetId.includes('your-sheet-id-here')) warning += ' Google Sheet ID not set in Admin Dashboard.';
        if (!apiKey) warning += ' Missing API_KEY_ALIAS_FOR_GEMINI environment variable.';
        console.warn(warning);
        return null;
    }

    const range = `${sheetName}!A:M`;
    const url = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${encodeURIComponent(range)}?key=${apiKey}`;
    const searchName = `${firstName.trim()} ${lastName.trim()}`.toLowerCase();

    try {
        const promise = fetch(url);
        const response = await withTimeout(promise, 20000);

        if (!response.ok) {
            const errorData = await response.json();
            console.error('Google Sheets API error:', errorData.error);
            throw new Error(`Failed to fetch from Google Sheets: ${errorData.error.message || response.statusText}`);
        }

        const data = await response.json();
        const rows = data.values;

        if (rows && rows.length) {
            for (const row of rows) {
                if (!row) continue; // Skip empty rows
                const rowFirstName = row[0] || '';
                const rowLastName = row[1] || '';
                const rowFullName = `${rowFirstName.trim()} ${rowLastName.trim()}`.toLowerCase();

                if (rowFullName === searchName) {
                    const studentId = row[12]; // Column M is at index 12
                    return studentId || null;
                }
            }
        }
        return null; // Student not found
    } catch (err: any) {
        console.error('Error processing request to Google Sheets API:', err);
        throw err;
    }
}


export enum PersonCategory {
  STAFF = 'Staff',
  STUDENT = 'Student',
  PARENT = 'Parent/Guardian',
}

type NewPersonData = {
  tempId: string;
  category: PersonCategory;
  firstName: string;
  lastName:string;
  image: string;
  role?: string;
  class?: string;
  guardianIds?: number[];
  guardianTempIds?: string[];
};

type AppContext = {
  Variables: {
    user: User;
    supabase: SupabaseClient;
  };
};

const app = new Hono<AppContext>().basePath('/api');

// --- MIDDLEWARE ---
app.use('/*', async (c, next) => {
  const authHeader = c.req.header('Authorization');
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return c.json({ error: 'Unauthorized' }, 401);
  }
  const supabase = createClient(
    process.env.SUPABASE_URL!,
    process.env.SUPABASE_ANON_KEY!,
    {
      global: { headers: { Authorization: authHeader } },
      auth: { autoRefreshToken: false, persistSession: false },
    }
  );
  const { data, error } = await supabase.auth.getUser();
  if (error || !data.user) {
    return c.json({ error: 'Invalid token' }, 401);
  }
  c.set('user', data.user);
  c.set('supabase', supabase);
  await next();
});

const adminOnly: MiddlewareHandler<AppContext> = async (c, next) => {
    const user = c.get('user');
    if (user.user_metadata?.role !== 'admin') {
        return c.json({ error: 'Forbidden: Admins only' }, 403);
    }
    await next();
};

const adminOrSecurity: MiddlewareHandler<AppContext> = async (c, next) => {
    const user = c.get('user');
    const role = user.user_metadata?.role;
    if (role !== 'admin' && role !== 'security') {
        return c.json({ error: 'Forbidden: Admin or Security role required' }, 403);
    }
    await next();
};


// --- HELPERS ---
async function uploadImageToStorage(supabase: SupabaseClient, base64Data: string, personName: string): Promise<string> {
    if (!base64Data || !base64Data.startsWith('data:image')) {
        return base64Data;
    }
    const base64Str = base64Data.replace(/^data:image\/\w+;base64,/, '');
    const binaryStr = atob(base64Str);
    const len = binaryStr.length;
    const imageBuffer = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        imageBuffer[i] = binaryStr.charCodeAt(i);
    }
    const mimeTypeMatch = base64Data.match(/data:(image\/\w+);base64,/);
    if (!mimeTypeMatch) throw new Error('Invalid image data URL');
    const mimeType = mimeTypeMatch[1];
    const fileExtension = mimeType.split('/')[1] || 'png';
    const sanitizedName = personName.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
    const filePath = `avatars/${sanitizedName}-${Date.now()}.${fileExtension}`;
    const { data, error } = await supabase.storage.from('avatars').upload(filePath, imageBuffer, { contentType: mimeType, upsert: false });
    if (error) {
        console.error('Supabase storage upload error:', error);
        throw new Error(`Failed to upload image: ${error.message}`);
    }
    const { data: { publicUrl } } = supabase.storage.from('avatars').getPublicUrl(data.path);
    return publicUrl;
}

const generateBio = async (ai: GoogleGenAI, firstName: string, lastName: string, category: PersonCategory, roleOrClass: string): Promise<string> => {
    const roleDescription = category === PersonCategory.STUDENT ? `a student in ${roleOrClass}` : `a ${roleOrClass}`;
    const prompt = `Generate a short, positive, one-sentence professional description for ${firstName} ${lastName}, who is ${roleDescription}. Keep it under 20 words. Example: 'A dedicated educator shaping future minds.' or 'An enthusiastic learner with a bright future.'`;
    const fallbackBio = "A valued member of our community.";
    try {
        const response = await withTimeout<GenerateContentResponse>(
            ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt }),
            20000
        );
        const bioText = (response.text ?? '').trim();
        return bioText || fallbackBio;
    } catch (error) {
        console.error("Error or timeout generating bio with Gemini:", error);
        return fallbackBio;
    }
};


// --- ROUTES ---
app.get('/settings', async (c) => {
    const supabase = c.get('supabase');
    const { data, error } = await supabase.from('settings').select('key, value');
    if (error) {
        console.error('Supabase settings fetch error:', error);
        return c.json({ error: 'Failed to fetch settings' }, 500);
    }
    if (!Array.isArray(data)) {
        return c.json({});
    }
    const settings = data.reduce((acc, row) => {
        if (row && row.key) acc[row.key] = row.value;
        return acc;
    }, {} as { [key: string]: string });
    return c.json(settings);
});

app.put('/settings', adminOnly, async (c) => {
    const supabase = c.get('supabase');
    const { key, value } = await c.req.json();
    if (!key || value === undefined) {
        return c.json({ error: 'Key and value are required' }, 400);
    }
    const { error } = await supabase.from('settings').upsert({ key, value });
    if (error) {
        console.error('Supabase settings update error:', error);
        return c.json({ error: 'Failed to update setting.', details: error.message, code: error.code }, 500);
    }
    return c.json({ success: true });
});

app.get('/people', async (c) => {
  const supabase = c.get('supabase');
  const page = parseInt(c.req.query('page') || '1');
  const limit = parseInt(c.req.query('limit') || '21');
  const search = c.req.query('search') || '';
  const from = (page - 1) * limit;
  const to = from + limit - 1;

  let query = supabase.from('people').select('*', { count: 'exact' });

  if (search) {
    const searchWords = search.trim().split(' ').filter(w => w.length > 0);
    const orConditions = searchWords.map(word => `firstName.ilike.%${word}%,lastName.ilike.%${word}%`).join(',');
    query = query.or(orConditions);
  }

  const { data: people, error, count } = await query.order('lastName').order('firstName').range(from, to);

  if (error) {
    console.error('Supabase fetch error:', error);
    return c.json({ error: `Failed to fetch people: ${error.message}` }, 500);
  }
  
  if (!Array.isArray(people) || people.length === 0) {
      return c.json({ people: [], total: count || 0 });
  }

  const studentGuardianIds = people
      .filter(p => p.category === PersonCategory.STUDENT && p.guardianIds?.length)
      .flatMap(p => p.guardianIds);

  if (studentGuardianIds.length > 0) {
      const uniqueGuardianIds = [...new Set(studentGuardianIds)];
      const { data: guardians, error: guardianError } = await supabase
          .from('people')
          .select('id, firstName, lastName, image')
          .in('id', uniqueGuardianIds);

      if (guardianError) {
          console.error('Failed to fetch guardian details:', guardianError);
      } else if (guardians) {
          const guardianMap = new Map(guardians.map(g => [g.id, g]));
          people.forEach((person: any) => {
              if (person.category === PersonCategory.STUDENT && person.guardianIds) {
                  person.guardianDetails = person.guardianIds
                      .map((id: number) => guardianMap.get(id))
                      .filter(Boolean);
              }
          });
      }
  }

  return c.json({ people, total: count || 0 });
});

app.get('/associates', async (c) => {
    const supabase = c.get('supabase');
    const search = c.req.query('search') || '';
    if (!search || search.length < 2) return c.json([]);
    let query = supabase.from('people').select('id, firstName, lastName, image').in('category', [PersonCategory.STAFF, PersonCategory.PARENT]);
    const searchWords = search.trim().split(' ').filter(w => w.length > 0);
    const orConditions = searchWords.map(word => `firstName.ilike.%${word}%,lastName.ilike.%${word}%`).join(',');
    query = query.or(orConditions);
    const { data, error } = await query.limit(10);
    if (error) {
        console.error('Supabase fetch associates error:', error);
        return c.json({ error: `Failed to fetch associates: ${error.message}` }, 500);
    }
    return c.json(data || []);
});

app.post('/people', async (c) => {
  const supabase = c.get('supabase');
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY_ALIAS_FOR_GEMINI! });
  const peopleToAdd: NewPersonData[] = await c.req.json();
  const warnings: string[] = [];

  if (!Array.isArray(peopleToAdd) || peopleToAdd.length === 0) {
    return c.json({ error: 'Invalid payload' }, 400);
  }

  try {
    const tempIdToNewIdMap: Record<string, number> = {};
    const studentPayloads: NewPersonData[] = [];
    const nonStudentPayloads: NewPersonData[] = [];

    peopleToAdd.forEach(p => {
        if (p.category === PersonCategory.STUDENT) studentPayloads.push(p);
        else nonStudentPayloads.push(p);
    });

    if (nonStudentPayloads.length > 0) {
      const nonStudentInsertData = await Promise.all(
        nonStudentPayloads.map(async (person) => ({
            category: person.category,
            firstName: person.firstName,
            lastName: person.lastName,
            image: await uploadImageToStorage(supabase, person.image, `${person.firstName}-${person.lastName}`),
            role: person.role,
            class: person.class,
            bio: await generateBio(ai, person.firstName, person.lastName, person.category, person.role || 'Parent'),
            googleSheetId: `GS-${Math.floor(10000 + Math.random() * 90000)}`,
        }))
      );
      
      const { data: inserted, error } = await supabase.from('people').insert(nonStudentInsertData).select('id');
      if (error) throw new Error(`Supabase non-student insert error: ${error.message}`);
      
      inserted.forEach((row, index) => {
          tempIdToNewIdMap[nonStudentPayloads[index].tempId] = row.id;
      });
    }

    if (studentPayloads.length > 0) {
        const studentInsertData = await Promise.all(
            studentPayloads.map(async (student) => {
                const newGuardianIds = student.guardianTempIds?.map(tempId => tempIdToNewIdMap[tempId]).filter(Boolean) || [];
                const allGuardianIds = [...new Set([...(student.guardianIds || []), ...newGuardianIds])];
                
                let googleSheetId: string;
                try {
                    googleSheetId = await getSheetIdForStudent(supabase, student.firstName, student.lastName) ?? `GS-${Math.floor(10000 + Math.random() * 90000)}`;
                } catch (e: any) {
                    console.warn(`Could not retrieve student ID from Google Sheet for ${student.firstName} ${student.lastName}. Falling back to random ID.`, e);
                    googleSheetId = `GS-${Math.floor(10000 + Math.random() * 90000)}`;
                    warnings.push(createSheetErrorWarning(`${student.firstName} ${student.lastName}`, e.message));
                }

                return {
                    category: student.category,
                    firstName: student.firstName,
                    lastName: student.lastName,
                    image: await uploadImageToStorage(supabase, student.image, `${student.firstName}-${student.lastName}`),
                    class: student.class,
                    guardianIds: allGuardianIds,
                    bio: await generateBio(ai, student.firstName, student.lastName, PersonCategory.STUDENT, student.class!),
                    googleSheetId: googleSheetId,
                }
            })
        );
        
        const { error } = await supabase.from('people').insert(studentInsertData);
        if (error) throw new Error(`Supabase student insert error: ${error.message}`);
    }

    return c.json({ success: true, warnings: warnings.length > 0 ? warnings : undefined }, 201);
  } catch (e: any) {
    console.error(e);
    return c.json({ error: 'Failed to create profiles', details: e.message }, 500);
  }
});

app.put('/people/:id', adminOnly, async (c) => {
    const supabase = c.get('supabase');
    const id = c.req.param('id');
    const updateData = await c.req.json();
    if (updateData.image && updateData.image.startsWith('data:image')) {
        updateData.image = await uploadImageToStorage(supabase, updateData.image, `${updateData.firstName}-${updateData.lastName}`);
    }
    const { error } = await supabase.from('people').update(updateData).eq('id', id);
    if (error) {
        console.error('Supabase update error:', error);
        return c.json({ error: 'Failed to update person', details: error.message }, 500);
    }
    return c.json({ success: true });
});

// --- ACCESS LOGS ROUTES ---
app.post('/logs', adminOrSecurity, async (c) => {
    const supabase = c.get('supabase');
    const user = c.get('user');
    const { personId, direction, location } = await c.req.json();
    if (!personId || !['entry', 'exit'].includes(direction) || !location) {
        return c.json({ error: 'Invalid payload: personId, direction, and location are required.' }, 400);
    }
    const { error } = await supabase.from('access_logs').insert({
        person_id: personId,
        direction,
        recorded_by: user.id,
        location,
    });
    if (error) {
        console.error('Error creating access log:', error);
        return c.json({ error: 'Failed to create access log.', details: error.message }, 500);
    }
    return c.json({ success: true }, 201);
});

app.get('/logs', adminOrSecurity, async (c) => {
    const supabase = c.get('supabase');
    const limit = parseInt(c.req.query('limit') || '20');
    
    // Step 1: Fetch raw logs to avoid PostgREST join issues with RLS
    const { data: logs, error } = await supabase
        .from('access_logs')
        .select('*')
        .order('created_at', { ascending: false })
        .limit(limit);

    if (error) {
        console.error('Error fetching recent logs:', error);
        return c.json({ error: 'Failed to fetch recent logs.', details: error.message }, 500);
    }
    if (!logs || logs.length === 0) {
        return c.json([]);
    }

    // Step 2: Enrich data using the admin client to bypass RLS
    const personIds = [...new Set(logs.map(log => log.person_id).filter(Boolean))];
    const recorderIds = [...new Set(logs.map(log => log.recorded_by).filter(Boolean))];

    try {
        const { supabaseAdmin } = await import('./supabaseAdminClient');
        
        // Fetch person details in parallel
        const peoplePromise = supabaseAdmin
            .from('people')
            .select('id, firstName, lastName, image')
            .in('id', personIds);

        // Fetch user (recorder) details in parallel
        const usersPromise = supabaseAdmin.auth.admin.listUsers({ perPage: 1000 });

        const [peopleResult, usersResult] = await Promise.all([peoplePromise, usersPromise]);

        if (peopleResult.error) throw peopleResult.error;
        const personMap = new Map(peopleResult.data.map(p => [p.id, { firstName: p.firstName, lastName: p.lastName, image: p.image }]));

        if (usersResult.error) throw usersResult.error;
        const userMap = new Map(usersResult.data.users.map((u: { id: string; email?: string; }): [string, string | undefined] => [u.id, u.email]));
        
        const enrichedLogs = logs.map((log: any) => ({
            ...log,
            person: personMap.get(log.person_id) || { firstName: 'Unknown', lastName: 'Person', image: '' },
            recorder: { email: userMap.get(log.recorded_by) || 'Unknown User' }
        }));
        
        return c.json(enrichedLogs);
    } catch(enrichError: any) {
        console.error('Error enriching log data:', enrichError);
        // Fallback to avoid crashing the frontend, providing raw logs
        return c.json(logs.map((log: any) => ({ 
            ...log, 
            person: { firstName: 'Error', lastName: 'Loading', image: '' }, 
            recorder: { email: 'Error Loading' } 
        })));
    }
});

app.get('/logs/analytics', adminOrSecurity, async (c) => {
    const supabase = c.get('supabase');
    const { data, error } = await supabase.rpc('get_parent_analytics').single();
    if (error) {
        console.error('Error fetching analytics:', error);
        return c.json({ error: 'Failed to fetch analytics data.', details: error.message }, 500);
    }
    return c.json(data);
});


app.get('/people/:id/logs', adminOrSecurity, async (c) => {
    const supabase = c.get('supabase');
    const personId = c.req.param('id');
    const { direction, startDate, endDate } = c.req.query();

    let query = supabase
        .from('access_logs')
        .select('*')
        .eq('person_id', personId);
    
    if (direction && direction !== 'all') {
        query = query.eq('direction', direction);
    }
    if (startDate) {
        query = query.gte('created_at', new Date(startDate).toISOString());
    }
    if (endDate) {
        // Add one day to include the entire end date
        const inclusiveEndDate = new Date(endDate);
        inclusiveEndDate.setDate(inclusiveEndDate.getDate() + 1);
        query = query.lt('created_at', inclusiveEndDate.toISOString());
    }

    const { data: logs, error } = await query.order('created_at', { ascending: false });

    if (error) {
        console.error(`Error fetching logs for person ${personId}:`, error);
        return c.json({ error: 'Failed to fetch access logs.', details: error.message }, 500);
    }
    if (!logs || logs.length === 0) {
        return c.json([]);
    }

    const recorderIds = [...new Set(logs.map(log => log.recorded_by).filter(Boolean))];
    if (recorderIds.length > 0) {
        try {
            const { supabaseAdmin } = await import('./supabaseAdminClient');
            const { data: { users }, error: usersError } = await supabaseAdmin.auth.admin.listUsers({ perPage: 1000 });
            if (usersError) throw usersError;
            
            const userMap = new Map(users.map((u: { id: string; email?: string; }): [string, string | undefined] => [u.id, u.email]));
            
            logs.forEach((log: any) => {
                log.recorder = { email: userMap.get(log.recorded_by) || 'Unknown User' };
            });
        } catch(usersError: any) {
            console.error('Error fetching recorder details:', usersError);
            logs.forEach((log: any) => {
                log.recorder = { email: 'Error fetching name' };
            });
        }
    }
    return c.json(logs);
});

// --- ADMIN ROUTES ---
const adminApp = new Hono<AppContext>();
adminApp.use('/*', adminOnly);

adminApp.get('/pending-users', async (c) => {
    try {
        const { supabaseAdmin } = await import('./supabaseAdminClient');
        const { data, error } = await supabaseAdmin.auth.admin.listUsers({ perPage: 1000 });
        if (error) throw error;
        // FIX: Cast `user` to `any` to bypass a potential type definition issue where `email_confirmed_at` might be missing from the User type returned by `listUsers`, causing a type inference problem.
        const pendingUsers = data.users.filter((user: any) => !user.email_confirmed_at).map((user: any) => ({
            id: user.id, email: user.email, created_at: user.created_at,
        }));
        return c.json(pendingUsers);
    } catch (e: any) {
        return c.json({ error: 'Admin client failed or failed to list users.', details: e.message }, 500);
    }
});

adminApp.post('/users/:id/confirm', async (c) => {
    const userId = c.req.param('id');
    try {
        const { supabaseAdmin } = await import('./supabaseAdminClient');
        const { data, error } = await supabaseAdmin.auth.admin.updateUserById(userId, { email_confirm: true });
        if (error) throw error;
        return c.json({ success: true, user: data.user });
    } catch (e: any) {
        return c.json({ error: 'Admin client failed or failed to confirm user.', details: e.message }, 500);
    }
});

adminApp.get('/users', async (c) => {
    try {
        const { supabaseAdmin } = await import('./supabaseAdminClient');
        const { data, error } = await supabaseAdmin.auth.admin.listUsers({ perPage: 1000 });
        if (error) throw error;
        const managedUsers = data.users.map(user => ({
            id: user.id, email: user.email, role: user.user_metadata?.role || 'user',
        }));
        return c.json(managedUsers);
    } catch (e: any) {
        return c.json({ error: 'Admin client failed or failed to list users.', details: e.message }, 500);
    }
});

adminApp.put('/users/:id/role', async (c) => {
    const userId = c.req.param('id');
    const { role } = await c.req.json();
    if (!['admin', 'user', 'security'].includes(role)) {
        return c.json({ error: 'Invalid role specified' }, 400);
    }
    try {
        const { supabaseAdmin } = await import('./supabaseAdminClient');
        const { data: { user: userToUpdate }, error: fetchError } = await supabaseAdmin.auth.admin.getUserById(userId);
        if (fetchError) throw fetchError;
        if (!userToUpdate) {
            return c.json({ error: 'User not found' }, 404);
        }
        const { data, error } = await supabaseAdmin.auth.admin.updateUserById(userId, {
            user_metadata: { ...userToUpdate.user_metadata, role },
        });
        if (error) throw error;
        return c.json({ success: true, user: data.user });
    } catch (e: any) {
        return c.json({ error: 'Admin client failed or update failed', details: e.message }, 500);
    }
});

adminApp.delete('/users/:id', async (c) => {
    const userId = c.req.param('id');
    const currentUser = c.get('user');
    if (userId === currentUser.id) {
        return c.json({ error: "Admins cannot delete their own account." }, 400);
    }
    try {
        const { supabaseAdmin } = await import('./supabaseAdminClient');
        const { error } = await supabaseAdmin.auth.admin.deleteUser(userId);
        if (error) throw error;
        return c.json({ success: true });
    } catch (e: any) {
        return c.json({ error: 'Failed to delete user', details: e.message }, 500);
    }
});

adminApp.post('/db-verify-repair', async (c) => {
    let logs: any[] = [];
    try {
        const { supabaseAdmin } = await import('./supabaseAdminClient');
        logs.push({ status: 'info', step: 'Check Storage Bucket: avatars', details: 'Verifying existence of "avatars" storage bucket.' });
        const { error: getError } = await supabaseAdmin.storage.getBucket('avatars');
        if (getError && getError.message.includes('Bucket not found')) {
            const { error: createError } = await supabaseAdmin.storage.createBucket('avatars', { public: true });
            if (createError) logs.push({ status: 'failure', step: 'Create Storage Bucket: avatars', details: `Failed to create bucket: ${createError.message}` });
            else logs.push({ status: 'success', step: 'Create Storage Bucket: avatars', details: 'Bucket "avatars" did not exist and was created successfully.' });
        } else if (getError) logs.push({ status: 'failure', step: 'Check Storage Bucket: avatars', details: `Error checking bucket: ${getError.message}` });
        else logs.push({ status: 'info', step: 'Check Storage Bucket: avatars', details: 'Bucket "avatars" already exists.' });

        logs.push({ status: 'info', step: 'Verify & Repair Schema', details: 'Calling database function to check tables, functions, and policies.' });
        
        let { data: schemaLogs, error: rpcError } = await supabaseAdmin.rpc('verify_and_repair_schema');
        
        if (rpcError && rpcError.message.includes('Could not find the function')) {
            logs.push({ status: 'warning', step: 'Self-Repair', details: '`verify_and_repair_schema` function not found. Attempting to create it now...' });
            
            // This is a workaround since the admin client doesn't directly support arbitrary SQL.
            // We are calling an empty RPC to execute the raw SQL string as a statement.
            // This relies on the database user having permission to create functions.
            // In Supabase, the 'postgres' user used by the admin client has these permissions.
            const { error: createError } = await supabaseAdmin.rpc('pg_catalog.current_database', {} , { head: true })
              // @ts-ignore - Hacking the client to send a statement
              .then(res => (res.error ? res : (supabaseAdmin as any).rest.rpc('verify_and_repair_schema', {}, {
                headers: { 'Content-Profile': 'public' },
                body: { sql: VERIFY_REPAIR_FUNCTION_SQL },
                method: 'POST',
              })));

            if (createError) {
                logs.push({ status: 'failure', step: 'Self-Repair', details: `Failed to create the repair function: ${createError.message}. Please run the setup SQL from the README manually.` });
            } else {
                logs.push({ status: 'success', step: 'Self-Repair', details: 'Successfully created the `verify_and_repair_schema` function. Re-running diagnostics...' });
                
                const { data: retryLogs, error: retryError } = await supabaseAdmin.rpc('verify_and_repair_schema');
                if (retryError) {
                    logs.push({ status: 'failure', step: 'Verify & Repair Schema (Retry)', details: `RPC call failed after creating function: ${retryError.message}` });
                } else {
                    logs = [...logs, ...retryLogs];
                }
            }
        } else if (rpcError) {
            logs.push({ status: 'failure', step: 'Verify & Repair Schema', details: `RPC call failed: ${rpcError.message}` });
        } else {
            logs = [...logs, ...schemaLogs];
        }
        
        return c.json({ logs });
    } catch (e: any) {
        logs.push({ status: 'failure', step: 'Overall Process', details: `An unexpected error occurred: ${e.message}` });
        return c.json({ logs }, 500);
    }
});

app.route('/admin', adminApp);

export default handle(app);